#usage "en: <b>Outputs the contents of a design to Sparkle Friendly list</b> "
"<p>Usage: run SparkFun-BOM_Generator</p>"
"<p>Author: <author>Owen Lyke, Nathan Seidle &lt;owen.lyke@sparkfun.com&gt;</author><br />"
"Version: <em>1.0</em></p>"


/*

#usage "en: <b>Outputs the contents of a design to Sparkle Friendly list</b> PCBWay requires the user to create panels that are at least 75x75mm. If the panel is smaller than this they will reject it because their v-score machine can't handle it. This ULP takes a given design and replicates it until the panel is just over the dimensions specified by the user. It also adds dimension lines between copies and v-score text so that PCBWay knows where to v-score. This script will also detect overhanging parts and warn the user that gaps are needed. Script tries to identify the soldermask color based on the logos on the board (SparkFun vs SparkX vs LilyPad). Script looks for 0.8mm tag for thin boards. Script outputs a ordering_instructions.txt file containing all the characteristics of this panel."
"<p>Usage: run bom_sparkle</p>"
"<p>Author: <author>Nathan Seidle &lt;inathan@sparkfun.com&gt;</author><br />"
"Version: <em>1.0</em></p>"

*/


// Modified October 2018, Owen Lyke
/*

Modification goals: 
- improve detection of false positives (a part that is on the board but doesn't exactly match a production part that can be used)
	* previous method was to search the part name and make sure it included the value

- output a format that sparkle can handle to automatically set the quantity (this depends on SWIT adding this functionality in sparkle first)
	* currently in-progress, requires SWIT support but can be easily adapted into the output format when needed

- improve detetion of on-board vs no-package components
	* answered by allowing the user to flag entries as "BOM" or "Non-BOM" while still not missing any board elements
	* also looping through boad elements as opposed to schematic elements helps

*/


string ulpName = "SparkFun-BOM_Generator";
int setup_complete = 0;
int redraw = 1;

int element_status_valid = 1;
int element_status_invalid = 2; 
int element_status_unknown = 0;

// Master lists
string prod_ids[];
string package_names[];
string values[];
string names[];
int quantities[];
int element_status[];
int numElements = 0;


// These two sets of lists are generated from the master lists above
string invalidlistarry[];
int invalidSort = 0;
int invalidSelected = -1;
int invalid_index_map[];


string validlistarry[];
int validSort = 0;
int validSelected = -1;
int valid_index_map[];

int validCount = 0;
int invalidCount = 0;

// A string for sparkle output
string sparkleBOM;


string pidFormat(string id_str)
{
	string numeral_entries[];
	int numEntries = strsplit(numeral_entries, id_str, '-');
	if(numEntries < 2)
	{
		// dlgMessageBox("Too few entries found in the product id");
		return "NaN";
	}
	string numerals = numeral_entries[1];
	while(numerals[0] == '0')
	{
		string t = strsub(numerals, 1, strlen(numerals));
		numerals = t;
	}

	return numerals;
}

void generateSparkleList()
{
	int invalidPIDcount = 0;
	sparkleBOM = "";
	for(int indi = 0; indi < validCount; indi++)
	{
		string temp = "";
		string prod_id = prod_ids[valid_index_map[indi]];
		string idNUM = pidFormat(prod_id);
		if(idNUM == "NaN"){
			invalidPIDcount++;
		}
		else if(indi < (validCount - 1))
		{
			sprintf(temp, "%s,", idNUM);
		}
		else
		{
			sprintf(temp, "%s", idNUM);
		}
		sparkleBOM += temp;
	}

	if(invalidPIDcount)
	{
		string msg = "";
		sprintf(msg, "Warning: %d items in BOM list without PROD_ID", invalidPIDcount);
		dlgMessageBox(msg);
	}
}

void categorizeElements()
{
	// Clear out the old lists
	for(int indk = 0; indk < validCount; indk++){
		validlistarry[indk] = "";
	}
	for(int indj = 0; indj < invalidCount; indj++)
	{
		invalidlistarry[indj] = "";
	}

	// Reset the counters
	validCount = 0;
	invalidCount = 0;

	// Recategorize the elements from the master lists
	for(int indi = 0; indi < numElements; indi++)
	{
		string temp = "";
		sprintf(temp, "%d\t%s\t%s\t%s", quantities[indi], prod_ids[indi], package_names[indi], names[indi]);
		if(element_status[indi] == element_status_valid){
			validlistarry[validCount] = temp;
			valid_index_map[validCount] = indi;
			validCount++;
		}
		else if(element_status[indi] == element_status_invalid)
		{
			invalidlistarry[invalidCount] = temp;
			invalid_index_map[invalidCount] = indi;
			invalidCount++;
		}
		else{
			// Problems have arisen
		}
	}

	generateSparkleList();
}


if(schematic)
{
	exit("edit .brd; run " + ulpName);
}
if(board)
{
	board(B){
		B.elements(E){

			string element_prod_id = E.attribute["PROD_ID"];
			string element_package_name = E.package.name;
			string element_value = E.attribute["Value"];
			string element_name = E.name;

			int match = 0;
			int indi = 0;

			if(element_prod_id)
			{
				// Search by product id
				for(int indi = 0; indi < numElements; indi++)
				{
					if(prod_ids[indi] == element_prod_id)
					{
						quantities[indi]++;
						match = 1;
					}
				}
				if(match == 0)
				{
					
					prod_ids[numElements] = element_prod_id;
					package_names[numElements] = element_package_name;
					quantities[numElements] = 1;
					values[numElements] = element_value;
					names[numElements] = element_name;
					element_status[numElements] = element_status_valid;
					numElements++;
				}
			}
			else{
				// Search by package
				for(int indi = 0; indi < numElements; indi++)
				{
					if(package_names[indi] == element_package_name)
					{
						quantities[indi]++;
						match = 1;
					}
				}
				if(match == 0)
				{
					
					prod_ids[numElements] = "";
					package_names[numElements] = element_package_name;
					quantities[numElements] = 1;
					values[numElements] = element_value;
					names[numElements] = element_name;
					element_status[numElements] = element_status_invalid;
					numElements++;
				}
			}
		}
	}


	categorizeElements();


	while(setup_complete != 1){

		dlgDialog("BOM Output"){

			dlgTabWidget {
				dlgTabPage("Filter Modification") {
					dlgHBoxLayout {
						dlgLabel("BOM Items");
						dlgLabel("Non-BOM Items");
					}
					dlgHBoxLayout {

						dlgListView("Qty\tPROD_ID\tPackage\tExample Name", validlistarry, validSelected, validSort);
						dlgListView("Qty\tPROD_ID\tPackage\tExample Name", invalidlistarry, invalidSelected, invalidSort);
					}
					dlgHBoxLayout {

						dlgPushButton("Move to Non-BOM") { 
							element_status[valid_index_map[validSelected]] = element_status_invalid;
							categorizeElements();
						}
						dlgPushButton("Move to BOM"){ 
							element_status[invalid_index_map[invalidSelected]] = element_status_valid;
							categorizeElements();
						}
					}
				}
				dlgTabPage("Sparkle Output") {
					dlgHBoxLayout {
						string msg = "This is where the Sparkle Product ids will go";
						dlgTextEdit(sparkleBOM);
					}
				}
	    }



	 		dlgGridLayout {

	 			dlgCell(0, 0){ 
	 				dlgPushButton("Done"){
	 					setup_complete = 1;
	 					// result = 0;
						dlgAccept();
					};
				};
	 		}

		};
	}

	exit(0);
}
else
{
	dlgMessageBox("Please run this ulp from the board editor");
	exit(1);
}